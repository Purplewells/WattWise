# 002 - Importance of CQRS

This document explains why Command Query Responsibility Segregation (CQRS) matters, where it is appropriate, what is required to write performant CQRS queries, and how it can be applied in this repository (WattWise).

## 1. Why CQRS is important

- Separation of concerns: CQRS splits read (query) responsibilities from write (command) responsibilities. This makes code easier to reason about, test, and evolve.
- Performance: Read models can be optimized independently of write models (e.g., denormalized views, indices, or specialized stores), enabling much faster queries for UI and reporting.
- Scalability: Read and write workloads often have different scaling characteristics. CQRS allows scaling them independently (replicate read side, shard write side, use read-optimized caches).
- Maintainability: Smaller, focused handlers and DTOs are simpler to understand and maintain than a single model handling both read and write concerns.
- Flexibility for advanced patterns: CQRS pairs well with Event Sourcing and eventual consistency patterns, enabling auditability, replayability, and complex business workflows.

## 2. Applicable scenarios

Use CQRS when:

- Your application has complex read requirements that differ significantly from write requirements (multiple read models, heavy reporting, dashboards).
- Read and write workloads are asymmetric (many more reads than writes), and you need to scale reads separately.
- You need to support different data models for reads vs writes (denormalized views, precomputed aggregates).
- You plan to adopt Event Sourcing or need an auditable history of changes.

Avoid CQRS when:

- The system is a simple CRUD app with symmetric read/write needs.
- Team size or project scope makes the extra complexity of separate models and eventual consistency unjustified.

## 3. What you need to write performant CQRS queries

To get good performance from the read side, consider the following practices:

- Design focused read DTOs: create small, shape-specific DTOs that include only the fields required by the UI or API. This avoids loading large entity graphs.
- Project with queries (EF Core projections): use LINQ `.Select(...)` to project directly to DTOs so the database returns only needed columns and avoids expensive tracking.
- Indexes and schema design: ensure the database has appropriate indexes for common queries; for denormalized views, choose a schema optimized for reads.
- Use async streaming and pagination: for large result sets, paginate and use async streaming (IAsyncEnumerable) where possible.
- Cache hot/read-heavy results: apply caching (in-memory, distributed cache) for frequently read data with appropriate invalidation on writes.
- Use lightweight data access for reads: in high-performance paths consider Dapper or raw SQL to avoid EF change-tracking overhead when not needed.
- Keep handlers thin and focused: query handlers should orchestrate the read and return DTOs — heavy business rules belong to the write side.
- Monitor and profile queries: log query durations, analyze SQL generated by EF, and optimize slow queries.

Practical checklist for a performant query handler:

- Return a purpose-built DTO (not the EF entity).
- Use `AsNoTracking()` for read-only EF queries.
- Project to DTOs in the query (avoid `Include()` unless you need full entities).
- Apply `Take`, `Skip`, and proper `ORDER BY` for pagination.
- Add database indexes for filters and joins used by the query.

## 4. Using CQRS in this application (WattWise)

This repository already follows a CQRS structure under `CQRS/` with `Commands/`, `Queries/`, `Handlers/`, and `DTOs/`. Examples in this project:

- DTO: [CQRS/DTOs/MeterDto.cs](CQRS/DTOs/MeterDto.cs)
- Query handler: [CQRS/Handlers/GetMeterByIdQueryHandler.cs](CQRS/Handlers/GetMeterByIdQueryHandler.cs)
- Controller usage: [Controllers/MetersController.cs](Controllers/MetersController.cs)

Example: a performant `GetMeterByIdQueryHandler` should project directly to `MeterDto` and use `AsNoTracking()` to avoid change tracking. Pseudocode example:

```csharp
// Query
public record GetMeterByIdQuery(Guid Id) : IRequest<MeterDto>;

// Handler (optimized read)
public class GetMeterByIdQueryHandler : IRequestHandler<GetMeterByIdQuery, MeterDto>
{
    private readonly ApplicationDbContext _db;

    public GetMeterByIdQueryHandler(ApplicationDbContext db) => _db = db;

    public async Task<MeterDto> Handle(GetMeterByIdQuery request, CancellationToken ct)
    {
        return await _db.Meters
            .AsNoTracking()
            .Where(m => m.Id == request.Id)
            .Select(m => new MeterDto
            {
                Id = m.Id,
                Name = m.Name,
                Serial = m.Serial,
                // map only required fields
            })
            .SingleOrDefaultAsync(ct);
    }
}
```

Controller usage (example already present in `Controllers/MetersController.cs`):

```csharp
// inside controller action
var dto = await _mediator.Send(new GetMeterByIdQuery(id));
return View(dto);
```

Notes specific to WattWise:

- The project includes `CQRS/DTOs/MeterDto.cs` and handlers — follow the pattern shown above when adding new queries to keep reads fast.
- For list endpoints (e.g., `GetMetersQuery`) ensure pagination, projection, and appropriate indexes on filtering/sorting columns.

## Quick recommendations

- Start with simple, well-indexed projections for reads.
- Measure before optimizing: use logging and EF SQL capture to find hotspots.
- Keep CQRS for bounded contexts or features that need it; don't apply it everywhere by default.

## References

- Martin Fowler on CQRS: <https://martinfowler.com/bliki/CQRS.html>
- Microsoft docs: Implementing CQRS with MediatR and EF Core

---
Created for WattWise — place this file in `Docs/` for team reference.

## Appendix — recent, practical suggestions (Meters)

These are actionable follow-ups and notes based on recent work converting Meter read handlers to DTO projections.

- Use `AsNoTracking()` and LINQ `.Select(...)` to project to `MeterDto` in query handlers to avoid EF change-tracking and unnecessary joins.
- Keep command handlers working with full `Meter` entities when you need to bind forms (Create/Edit/Delete POST), but use DTOs for Index/Details views.
- For list endpoints (`GetMetersQuery`): paginate, project only required columns, and add database indexes for common filters/sorts (e.g., `SerialNumber`, `Location`, `UserId`).
- For Details (`GetMeterByIdQuery`): return a single `MeterDto` shaped for the UI; avoid loading navigation objects unless you need full related entities.
- Update controllers so GET actions that render edit/delete forms fetch entities from `ApplicationDBContext` (tracked) while Index/Details use mediator queries that return DTOs (untracked).
- Update views to accept `MeterDto` for read-only pages (`Index`, `Details`) and use simple ID properties (e.g., `TamperStatusID`) instead of navigation chains.

Checklist to finish the Meter UI flow:

- [ ] Run `dotnet build` and fix any compile issues introduced by DTO typing changes.
- [ ] Run the app and visit `/Meters` and `/Meters/Details/{id}` to validate rendering.
- [ ] Add unit tests for `GetMetersQueryHandler` and `GetMeterByIdQueryHandler` that assert projection shape and no tracking.
- [ ] Add EF logging (or enable sensitive data logging temporarily) to inspect generated SQL for these queries.
- [ ] Add indexes for columns used by filters/sorts and measure query performance.

Suggested next tasks you can pick from:

- Convert other read handlers to DTO projections for performance (e.g., `GetMetersQuery` is already converted; repeat for similar features).
- Add automated tests and a CI build step that runs `dotnet build` and unit tests.
- Add simple caching for very hot, read-heavy endpoints (in-memory or distributed cache) with invalidation on write commands.

This appendix documents the immediate, practical recommendations for Meters and how to finish the UI integration.
